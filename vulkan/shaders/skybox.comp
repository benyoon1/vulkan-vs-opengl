#version 450
layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba8,set = 0, binding = 0) uniform image2D image;

// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

//push constants block
layout( push_constant ) uniform constants
{
    mat4 inverseProjection;
    mat4 inverseView;
    vec4 screenSize;
    vec4 sunDirection;
} PushConstants;

// // Return random noise in the range [0.0, 1.0], as a function of x.
// float Noise2d( in vec2 x )
// {
//     float xhash = cos( x.x * 37.0 );
//     float yhash = cos( x.y * 57.0 );
//     return fract( 415.92653 * ( xhash + yhash ) );
// }

// // Convert Noise2d() into a "star field" by stomping everthing below fThreshhold to zero.
// float NoisyStarField( in vec2 vSamplePos, float fThreshhold )
// {
//     float StarVal = Noise2d( vSamplePos );
//     if ( StarVal >= fThreshhold )
//         StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );
//     else
//         StarVal = 0.0;
//     return StarVal;
// }

// // Stabilize NoisyStarField() by only sampling at integer values.
// float StableStarField( in vec2 vSamplePos, float fThreshhold )
// {
//     // Linear interpolation between four samples.
//     // Note: This approach has some visual artifacts.
//     // There must be a better way to "anti alias" the star field.
//     float fractX = fract( vSamplePos.x );
//     float fractY = fract( vSamplePos.y );
//     vec2 floorSample = floor( vSamplePos );    
//     float v1 = NoisyStarField( floorSample, fThreshhold );
//     float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );
//     float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );
//     float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );

//     float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )
//         			+ v2 * ( 1.0 - fractX ) * fractY
//         			+ v3 * fractX * ( 1.0 - fractY )
//         			+ v4 * fractX * fractY;
// 	return StarVal;
// }

// void mainImage( out vec4 fragColor, in vec2 fragCoord )
// {
//     vec2 iResolution = imageSize(image);
// 	// Sky Background Color
// 	//vec3 vColor = vec3( 0.1, 0.2, 0.4 ) * fragCoord.y / iResolution.y;
//     vec3 vColor = PushConstants.data1.xyz * fragCoord.y / iResolution.y;

//     // Note: Choose fThreshhold in the range [0.99, 0.9999].
//     // Higher values (i.e., closer to one) yield a sparser starfield.
//     float StarFieldThreshhold = PushConstants.data1.w;//0.97;

//     // Stars with a slow crawl.
//     float xRate = 0.2;
//     float yRate = -0.06;
//     vec2 vSamplePos = fragCoord.xy + vec2( xRate * float( 1 ), yRate * float( 1 ) );
// 	float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );
//     vColor += vec3( StarVal );
	
// 	fragColor = vec4(vColor, 1.0);
// }

// uniform mat4 inverseProjection;
// uniform mat4 inverseView;
// uniform vec2 screenSize;
// uniform vec3 sunDirection;

// --- UTILITY FUNCTIONS ---
float random(vec3 p) {
    p = fract(p * vec3(443.8975, 441.4234, 437.1956));
    p += dot(p, p.yzx + 19.19);
    return fract((p.x + p.y) * p.z);
}
float noise(vec3 st) {
    vec3 i = floor(st);
    vec3 f = fract(st);
    float a = random(i);
    float b = random(i + vec3(1.0, 0.0, 0.0));
    float c = random(i + vec3(0.0, 1.0, 0.0));
    float d = random(i + vec3(1.0, 1.0, 0.0));
    float e = random(i + vec3(0.0, 0.0, 1.0));
    float f_ = random(i + vec3(1.0, 0.0, 1.0));
    float g = random(i + vec3(0.0, 1.0, 1.0));
    float h = random(i + vec3(1.0, 1.0, 1.0));
    vec3 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) +
    (c - a) * u.y * (1.0 - u.x) +
    (d - b) * u.y * u.x +
    (e - a) * u.z * (1.0 - u.y) * (1.0 - u.x) +
    (f_ - b) * u.z * (1.0 - u.y) * u.x +
    (g - c) * u.z * u.y * (1.0 - u.x) +
    (h - d) * u.z * u.y * u.x;
}
float fbm(vec3 p) {
    float f = 0.0;
    f += 0.5 * noise(p);
    p *= 2.02;
    f += 0.25 * noise(p);
    p *= 2.03;
    f += 0.125 * noise(p);
    p *= 2.01;
    f += 0.0625 * noise(p);
    return f / 0.9375;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 ndc = (vec2(texelCoord) + 0.5) / PushConstants.screenSize.xy * 2.0 - 1.0;
    vec4 clip = vec4(ndc, 1.0, 1.0);
    vec4 viewSpace = PushConstants.inverseProjection * clip;
    viewSpace.xyz /= viewSpace.w;
    vec3 worldDir = (PushConstants.inverseView * vec4(viewSpace.xyz, 0.0)).xyz;
    vec3 viewDir = normalize(worldDir);

    // Day/Night Factors
    float sunDot = max(0.0, dot(viewDir, PushConstants.sunDirection.xyz));
    float nightFactor = 1.0 - smoothstep(-0.1, 0.1, PushConstants.sunDirection.y);
    float sunsetFactor = smoothstep(0.0, 0.08, PushConstants.sunDirection.y) * smoothstep(0.15, 0.05, PushConstants.sunDirection.y);

    vec3 daySkyColor = vec3(0.3, 0.6, 0.95);
    vec3 nightSkyColor = vec3(0.006, 0.012, 0.024);
    vec3 horizonColor = vec3(0.9, 0.75, 0.5);
    float horizonGlow = pow(1.0 - max(0.0, viewDir.y), 5.0);
    vec3 skyColor = mix(daySkyColor, horizonColor, horizonGlow);
    vec3 deepRedSunsetColor = vec3(0.9, 0.25, 0.0);
    skyColor = mix(skyColor, deepRedSunsetColor, sunsetFactor * 0.7);
    skyColor = mix(skyColor, nightSkyColor, nightFactor);
    vec3 middaySunColor = vec3(1.0, 0.95, 0.85);
    vec3 settingSunColor = vec3(1.0, 0.6, 0.2);
    vec3 dynamicSunColor = mix(middaySunColor, settingSunColor, sunsetFactor * 1.5);
    float sunHaze = pow(sunDot, 16.0);
    float sunGlow = pow(sunDot, 256.0);
    float sunCore = pow(sunDot, 1024.0);
    float sunPhotosphere = pow(sunDot, 4096.0);
    vec3 sunColor = (sunHaze * 0.4 + sunGlow * 0.6 + sunCore * 1.2 + sunPhotosphere * 0.5) * dynamicSunColor;
    sunColor *= 1.0 - nightFactor;

    vec3 finalColor = skyColor + sunColor;
    finalColor = finalColor / (finalColor + vec3(1.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));
    // FragColor = vec4(finalColor, 1.0);

    // ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);
    if(texelCoord.x < size.x && texelCoord.y < size.y)
    {
        // vec4 color;
        // mainImage(color,texelCoord);
    
        imageStore(image, texelCoord, vec4(finalColor, 1.0));
    }   

}

// void main() 
// {
// 	// vec4 value = vec4(0.0, 0.0, 0.0, 1.0);
//     ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
// 	ivec2 size = imageSize(image);
//     if(texelCoord.x < size.x && texelCoord.y < size.y)
//     {
//         vec4 color;
//         // mainImage(color,texelCoord);
    
//         imageStore(image, texelCoord, color);
//     }   
// }